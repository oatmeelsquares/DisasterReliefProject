---
title: 'Disaster Relief Project, Part 1'
author: "Becky Desrosiers, Abner Casillas-Colon, Rachel Daniel"
date: "2024-03-16"
output: pdf_document
---

```{r r-setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(cache = TRUE,
                      autodep = TRUE,
                      message = FALSE,
                      warning = FALSE)
library(tidyverse)
library(tidymodels)
library(ggcorrplot)
library(GGally)
library(discrim)
library(patchwork)
library(doParallel)
cl <- makePSOCKcluster(parallel::detectCores(logical = FALSE))
registerDoParallel(cl)
```


# Section 1: Introduction

The 2010 earthquake in Haiti was a devastating natural disaster that caused extreme damaged and displaced millions of people. After this disaster, the rescue workers needed to deliver food, water, and other resources to the people of Haiti, but it was challenging locating the people in need over this large area. These challenges included roads blocked by rubble and the inability to communicate as traditional lines of communication were destroyed by the earthquake. The rescue workers needed to find another strategy other than physically looking for them on land to locate and reach these displaced persons quickly and more efficiently. 

The people of Haiti who were displaced by the earthquake were using blue tarps as temporary shelter. This knowledge was utilized to locate these people after imagery was collected by aircraft flown by a rescue team from the Rochester Institute of Technology. Blue tarps could be searched for within these images by the rescue team who would then go to these coordinates and find them. However, that strategy would have been too slow, and resources would not have been delivered in time. A different strategy that could be used to more efficiently locate people in need of resources was to continue to use these images but instead use data-mining algorithms to search these images. 

This report explores various classification methods that could be useful in locating these blue tarps within the imagery taken by aircraft. The algorithms tested and explored include those that utilize Logistic Regression, Linear Discriminant Analysis, Quadratic Discriminant Analysis, K-nearest Neighbors, and Penalized Logistic Regression. We expect at least one of these methods to work more efficiently and more accurately than human efforts as these algorithms can handle more data, perform complex operations, and potentially fit to the patterns of the data to identify the blue tarps. The chosen algorithm may be less likely to miss as many blue tarps as a human would, and it is critical to identify that algorithm that will perform the best. This is an important data-mining problem that could have a large impact on human life. This report will identify the algorithm that most accurately and most efficiently identifies these blue tarps so that the displaced persons in Haiti in need of resources can receive them on time. 


# Section 2: Data

```{r load-data, warning = FALSE, message = FALSE}
# load data from file
# file = "https://gedeck.github.io/DS-6030/project/HaitiPixels.csv"
file = '../data.csv'
data <- read_csv(file) %>% 
  mutate(Class = factor(ifelse(Class == 'Blue Tarp', 'Tarp', 'Non-Tarp')))

data %>% glimpse()
data %>% summary()
```
>You will need to do some EDA
- EDA - focus your discussion of the results on what it means for the model
- Be selective with your EDA. Focus on results that have a relevance to the project. You can always mention that you tried other visualizations, but didn’t get much more out of it. If you add a graph, it should add to your analysis and cover something that cannot already be seen in other graphs.





# Section 3: Description of Methodology

>Overall model building process well defined and explained.
• describe used software
• describe and justify parameter tuning and model selection (if applicable)
• describe and justify model validation
• describe and justify threshold selection
• describe and justify metrics used for model performance evaluation

>Model training consists of these steps:
- Model validation using 10-fold cross validation; this includes model tuning if applicable
- what metric will you use?
- Threshold selection
- what metric will you use?
- Are “penalized logistic regression” and “logistic regression” really two different models or just variations of the same?

>From Becky: be sure to mention we did a 20-80 test-training split with stratified sampling of Blue Tarp pixels.

This model is created using RStudio with the following packages: tidyverse, tidymodels, ggcorrplot, GGally, patchwork, discrim and doParallel. RStudio is an open-source statistical analysis software that offers a variety of packages to assist in model building and model selection. The first step of this analysis is to change the classifier into our variable of interest, Blue Tarp and all other classes. As the goal of this model will be to predict the class of a combination of pixels the following classification models will be explored: Logistic Regression, Penalized Logistic Regression (a logistic regression model with tuning parameters for an elastic net), LDA, QDA, and a KNN model.
	Of these models only the KNN model and the Logistic Regression Model will utilize tuning parameters. For the KNN model the selected tuning parameters are the number of neighbors and the number of dimensions for the PCA. The optimal tuning parameters for the KNN model are 24 neighbors and all 3 dimensions. This selection makes sense as each of the variables is important in determining a certain class of value if we consider how pixels as three values that contribute to a greater image. For the penalized model the optimal values were a mixture of .198 and a penalty of 3.96e-17. These values more closely align with a ridge regression a miniscule penalty factor, which is similar to how the PCA highlights the importance of all three variables as opposed to shrinking one of the variables more than the others.
	For all models a 10-fold cross validation was chosen as the methodology for model validation. With an overall sample size of 63,241 and a training set of 50,593 this allows for each fold to have 5,059 records.  With this amount a 10-fold cross validation is a reliable method to evaluate the performance of the training sets for all models.
	For all metrics the primary selection criteria was the ROC AUC. This metric provides a method to evaluate the performance of the True Positive Rate and False Positive Rate across all possible thresholds from 0 to 1.  With its efficacy as an overall evaluator of performance this is what will be used for model selection when comparing all versions of the 10-fold validation models. 
	As established during the EDA the proportion of Blue Tarps to all other classes is approximately 3%. This indicates that a 50% threshold would be a poor choice for the final model.  While four metrics will be explored for threshold selection (accuracy, j-index, sensitivity, and specificity) our primary metrics of interest will be sensitivity and j-index. For sensitivity we want to minimize false negatives since these would be individuals that could be missed when response time is extremely important. The J-index is chosen as a metric that balances sensitivity and specificity. This would be valuable in models were responders have limited resources to check potential points of interest. While we do have higher false negatives, we have vastly reduced false positives that allows for lower potential locations to check.



# Section 4: Results of Model Fitting, Tuning Parameter Selection, and Evaluation


>Model performance summarized in one or more tables or figures. Expected information shown:
• ROC curves and AUC
• Optimal model tuning parameters
• Selected threshold
• Accuracy, TPR, FPR, Precision calculated at selected threshold

>When you present metrics, talk about their relevance for the objective of this project
- When you present your results, split it into results from model validation and results after threshold selection. e.g. ROC curves are only relevant for discussing model validation results and not threshold selection; reporting accuracy or any other threshold dependent metric prior to threshold selection is irrelevant.
- If you visualize the same analysis for each model, combine them either in a single graph or a combination of graphs in one figure (using patchwork)

>Focus your discussion also on differences between models.
- For example LDA and QDA are conceptually similar but differ in the way they can represent the decision boundary. 
- What do the differences in the results for LDA and QDA tell you?
- Another example that you can discuss is the difference between , penalized logistic regression and logistic regression.





```{r convenience-functions}
# define functions to use later for convenience
cv_control <- control_resamples(save_pred = TRUE)

roc_plot <- function(model_preds) {
  model_preds %>% 
    roc_curve(truth = Class,
              .pred_Tarp,
              event_level = 'second') %>% 
    autoplot()
}

threshold_metric_plot <- function(thresh_perf, max_sens, max_j) {
  ggplot(thresh_perf, aes(x = .threshold, y = .estimate, color = .metric)) +
    geom_line() +
    geom_vline(data = max_sens, aes(xintercept = .threshold, color = .metric)) +
    geom_vline(data = max_j, aes(xintercept = .threshold, color = .metric)) +
    scale_x_continuous(breaks = seq(0, 1, 0.1)) +
    labs(x = 'Threshold', y = 'Metric value')
}

threshold_metrics <- metric_set(j_index,
                                specificity,
                                sensitivity,
                                accuracy,
                                precision)


threshold_preds <- function(preds, threshold) {
    preds <- preds %>% 
    mutate(.pred_class = factor(ifelse(.pred_Tarp >= threshold, 'Tarp', 'Non-Tarp')))
}

```


```{r model-setup}
# prepare resamples for 10-fold cross-validation
set.seed(6030)
resamples <- vfold_cv(data, v = 10, strata=Class)

# define formula
formula <- Class ~ Red + Green + Blue

# define basic recipe
rec <- recipe(formula, data = data)
```


## Section 3.5.5: K-Nearest Neighbors


```{r knn}
# define model spec
knn_spec <- nearest_neighbor(mode = 'classification',
                            engine = 'kknn',
                            neighbors = parsnip::tune())

# define workflow
knn_wf <- workflow() %>% 
  add_recipe(rec) %>% 
  add_model(knn_spec)

# set tuning parameters
knn_params <- extract_parameter_set_dials(knn_wf) %>% 
  update(neighbors = neighbors(c(2, 50)))

# tune with grid (or fit resamples)
knn_tune <- tune_grid(knn_wf,
                      resamples = resamples,
                      grid = grid_regular(knn_params, levels = 49),
                      control = cv_control
                      )

# get tuning results visualization
knn_tune_vis <- autoplot(knn_tune)$roc_auc

# finalize workflow and fit resamples with best parameters
knn_best_params <- select_by_one_std_err(knn_tune, neighbors, metric = 'roc_auc')

knn_fitcv <- knn_wf %>% 
  finalize_workflow(knn_best_params) %>% 
  fit_resamples(resamples,
                control = cv_control
                )

# collect predictions and roc_auc from cross-validated fit
knn_preds <-  collect_predictions(knn_fitcv)
knn_metrics <- collect_metrics(knn_fitcv)

# get ROC plot
knn_roc <- roc_plot(knn_preds)

# get threshold selection info
knn_thresh_perf <- probably::threshold_perf(knn_preds,
                                            Class,
                                            .pred_Tarp,
                                            thresholds = seq(0.01, 0.99, 0.01),
                                            event_level = 'second',
                                            metrics = metric_set(j_index,
                                                                 specificity,
                                                                 sensitivity,
                                                                 accuracy))

# get threshold for best sensitivity
knn_max_sens <- knn_thresh_perf %>% 
  filter(.metric == 'sensitivity') %>% 
  filter(.estimate == max(.estimate))

# get threshold for best j-index
knn_max_j <- knn_thresh_perf %>% 
  filter(.metric == 'j_index') %>% 
  filter(.estimate == max(.estimate))

# get threshold metrics plot
knn_tmetrics_plot <- threshold_metric_plot(knn_thresh_perf, knn_max_sens, knn_max_j)

# get predictions and metrics based on chosen threshold
knn_threshold_preds <- knn_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.04, 'Tarp', 'Non-Tarp')))

knn_threshold_metrics <- threshold_metrics(knn_threshold_preds,
                                           truth = Class,
                                           estimate = .pred_class)

# get confusion matrix for chosen threshold
knn_cm <- conf_mat(knn_threshold_preds, truth = Class, estimate = .pred_class)
```


We will now build a K-nearest neighbors (KNN) model with the number of neighbors, k, tuned to find the best fit. 



# Linear Discriminant Analysis

```{r lda}
# define model spec
lda_spec <- discrim_linear(mode = "classification") %>% 
  set_engine('MASS')

# define workflow
lda_wf <- workflow() %>% 
  add_recipe(rec) %>% 
  add_model(lda_spec)


#fit resamples
lda_fitcv <- fit_resamples(lda_wf, resamples,  control=cv_control)

# collect predictions and roc_auc from cross-validated fit
lda_preds <-  collect_predictions(lda_fitcv)
lda_metrics <- collect_metrics(lda_fitcv)
#will just talk about ROC in write up without graph/listed metrics

# get threshold selection info
lda_thresh_perf <- probably::threshold_perf(lda_preds,
                                            Class,
                                            .pred_Tarp,
                                            thresholds = seq(0.01, 0.99, 0.01),
                                            event_level = 'second',
                                            metrics = metric_set(j_index,
                                                                 specificity,
                                                                 sensitivity,
                                                                 accuracy))

# get threshold for best sensitivity
lda_max_sens <- lda_thresh_perf %>% 
  filter(.metric == 'sensitivity') %>% 
  filter(.estimate == max(.estimate))

# get threshold for best j-index
lda_max_j <- lda_thresh_perf %>% 
  filter(.metric == 'j_index') %>% 
  filter(.estimate == max(.estimate))

# get threshold metrics plot
lda_tmetrics_plot <- threshold_metric_plot(lda_thresh_perf, lda_max_sens, lda_max_j)

# get predictions and metrics based on chosen threshold
lda_threshold_preds <- lda_preds %>% 
 mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.01, 'Tarp', 'Non-Tarp')))

lda_threshold_metrics <- threshold_metrics(lda_threshold_preds, truth = Class, estimate = .pred_class)
lda_threshold_metrics

# get confusion matrix for chosen threshold
lda_cm <- conf_mat(lda_threshold_preds, truth = Class, estimate = .pred_class)

```

# Quadratic Discriminant Analysis

```{r qda}
# define model spec
qda_spec <- discrim_quad(mode = "classification") %>% 
  set_engine('MASS')

# define workflow
qda_wf <- workflow() %>% 
  add_recipe(rec) %>% 
  add_model(qda_spec)


#fit resamples
qda_fitcv <- fit_resamples(qda_wf, resamples,  control=cv_control)

# collect predictions and roc_auc from cross-validated fit
qda_preds <-  collect_predictions(qda_fitcv)
qda_metrics <- collect_metrics(qda_fitcv)
#will just talk about ROC in write up without graph/listed metrics

# get threshold selection info
qda_thresh_perf <- probably::threshold_perf(qda_preds,
                                            Class,
                                            .pred_Tarp,
                                            thresholds = seq(0.01, 0.99, 0.01),
                                            event_level = 'second',
                                            metrics = metric_set(j_index,
                                                                 specificity,
                                                                 sensitivity,
                                                                 accuracy))

# get threshold for best sensitivity
qda_max_sens <- qda_thresh_perf %>% 
  filter(.metric == 'sensitivity') %>% 
  filter(.estimate == max(.estimate))

# get threshold for best j-index
qda_max_j <- qda_thresh_perf %>% 
  filter(.metric == 'j_index') %>% 
  filter(.estimate == max(.estimate))

# get threshold metrics plot
qda_tmetrics_plot <- threshold_metric_plot(qda_thresh_perf, qda_max_sens, qda_max_j)


# get predictions and metrics based on chosen threshold
qda_threshold_preds <- qda_preds %>% 
 mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.01, 'Tarp', 'Non-Tarp')))

qda_threshold_metrics <- threshold_metrics(qda_threshold_preds, truth = Class, estimate = .pred_class)


# get confusion matrix for chosen threshold
qda_cm <- conf_mat(qda_threshold_preds, truth = Class, estimate = .pred_class)
```

> Write-up


```{r knn-auc-vs-metrics}
#| fig.width: 9
#| fig.height: 5
#| fig.align: center
#| out.width: 70%
#| fig.cap: Plot of ROC curve for the logistic regression model with no penalty. The AUC is 0.9976.
#| dev: "png"
#| dpi: 100
# display logreg ROC curve
roc_plot(logreg_preds)
```

> describe ROC curve, report AUC (without printing it out), and 

Figure 1 shows the corresponding ROC curve to demonstrate the performance of the model. We note a very high AUC of **0.9987**, indicating a very effective model. From the visualization and the ROC AUC metric, it is clear that the model performs well. To optimize its predictive capability, we now investigate further to choose a threshold.












```{r compare-metrics}
compare_metrics <- bind_rows(log_threshold_metrics %>% mutate(model = 'logistic regression'),
                             penlog_threshold_metrics %>% mutate(model = 'penalized logreg'),
                             lda_threshold_metrics %>% mutate(model = 'LDA'),
                             qda_threshold_metrics,
                             knn_threshold_metrics)
```





# Section 5: Conclusion


>Three or more clearly identifiable conclusions. This section is more important than the previous sections (as
reflected in the points). Give sufficient explanation and justification for each conclusion.
One conclusion must be:
• determination and justification of which algorithm works best.
Additional conclusions should be observations you’ve made based on your work on this project, such as:
• What additional recommend actions can be taken to improve results?
• Were there multiple adequately performing methods, or just one clear best method? What is your level
of confidence in the results?
• What is it about this data formulation that allows us to address it with predictive modeling tools?
• How effective do you think your work here could actually be in terms of helping to save human life?
• Do these data seem particularly well-suited to one class of prediction methods, and if so, why?
These are only suggestions, pursue your own interests. Your best two additional conclusions will be graded.
Make sure that the 3 conclusions are clearly separated.










# Appendix

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
stopCluster(cl)
registerDoSEQ()
```
