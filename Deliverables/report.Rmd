---
title: 'Disaster Relief Project, Part 1'
author: "Becky Desrosiers, Abner Casillas-Colon, Rachel Daniel"
date: "2024-03-16"
output: pdf_document
---

```{r r-setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(cache = TRUE,
                      autodep = TRUE,
                      message = FALSE,
                      warning = FALSE)
library(tidyverse)
library(tidymodels)
library(ggcorrplot)
library(GGally)
library(discrim)
library(patchwork)
library(doParallel)
cl <- makePSOCKcluster(parallel::detectCores(logical = FALSE))
registerDoParallel(cl)
```


# Section 1: Introduction

>What is the key idea for locating people and why do we expect it to work?



# Section 2: Data

```{r load-data, warning = FALSE, message = FALSE}
# load data from file
# file = "https://gedeck.github.io/DS-6030/project/HaitiPixels.csv"
file = '../data.csv'
data <- read_csv(file) %>% 
  mutate(Class = factor(ifelse(Class == 'Blue Tarp', 'Tarp', 'Non-Tarp')))

data %>% glimpse()
data %>% summary()
```
>You will need to do some EDA
- EDA - focus your discussion of the results on what it means for the model
- Be selective with your EDA. Focus on results that have a relevance to the project. You can always mention that you tried other visualizations, but didn’t get much more out of it. If you add a graph, it should add to your analysis and cover something that cannot already be seen in other graphs.





# Section 3: Description of Methodology

>Overall model building process well defined and explained.
• describe used software
• describe and justify parameter tuning and model selection (if applicable)
• describe and justify model validation
• describe and justify threshold selection
• describe and justify metrics used for model performance evaluation

>Model training consists of these steps:
- Model validation using 10-fold cross validation; this includes model tuning if applicable
- what metric will you use?
- Threshold selection
- what metric will you use?
- Are “penalized logistic regression” and “logistic regression” really two different models or just variations of the same?

>From Becky: be sure to mention we did a 20-80 test-training split with stratified sampling of Blue Tarp pixels.




# Section 4: Results of Model Fitting, Tuning Parameter Selection, and Evaluation


>Model performance summarized in one or more tables or figures. Expected information shown:
• ROC curves and AUC
• Optimal model tuning parameters
• Selected threshold
• Accuracy, TPR, FPR, Precision calculated at selected threshold

>When you present metrics, talk about their relevance for the objective of this project
- When you present your results, split it into results from model validation and results after threshold selection. e.g. ROC curves are only relevant for discussing model validation results and not threshold selection; reporting accuracy or any other threshold dependent metric prior to threshold selection is irrelevant.
- If you visualize the same analysis for each model, combine them either in a single graph or a combination of graphs in one figure (using patchwork)

>Focus your discussion also on differences between models.
- For example LDA and QDA are conceptually similar but differ in the way they can represent the decision boundary. 
- What do the differences in the results for LDA and QDA tell you?
- Another example that you can discuss is the difference between , penalized logistic regression and logistic regression.





```{r convenience-functions}
# define functions to use later for convenience
cv_control <- control_resamples(save_pred = TRUE)

roc_plot <- function(model_preds) {
  model_preds %>% 
    roc_curve(truth = Class,
              .pred_Tarp,
              event_level = 'second') %>% 
    autoplot()
}

threshold_metric_plot <- function(model_preds) {
  
  thresh_perf <- probably::threshold_perf(model_preds,
                                          Class,
                                          .pred_Tarp,
                                          thresholds = seq(0.01, 0.99, 0.01),
                                          event_level = 'second',
                                          metrics = threshold_metrics)

  max_sens <- thresh_perf %>% 
    filter(.metric == 'sensitivity') %>% 
    filter(.estimate == max(.estimate))

  max_j <- thresh_perf %>% 
    filter(.metric == 'j_index') %>% 
    filter(.estimate == max(.estimate))

  ggplot(thresh_perf, aes(x = .threshold, y = .estimate, color = .metric)) +
    geom_line() +
    geom_vline(data = max_sens, aes(xintercept = .threshold, color = .metric)) +
    geom_vline(data = max_j, aes(xintercept = .threshold, color = .metric)) +
    scale_x_continuous(breaks = seq(0, 1, 0.1)) +
    labs(x = 'Threshold', y = 'Metric value')
  
  # print(bind_rows(max_sens, max_j) %>% 
  #   pivot_wider(names_from = .metric,
  #               values_from = .estimate)
  # )
}

threshold_metrics <- metric_set(j_index,
                                specificity,
                                sensitivity,
                                accuracy)


threshold_preds <- function(preds, threshold) {
    preds <- preds %>% 
    mutate(.pred_class = factor(ifelse(.pred_Tarp >= threshold, 'Tarp', 'Non-Tarp')))
}

```


```{r model-setup}
# prepare resamples for 10-fold cross-validation
set.seed(6030)
resamples <- vfold_cv(data, v = 10, strata=Class)

# define formula
formula <- Class ~ Red + Green + Blue

# define basic recipe
rec <- recipe(formula, data = data)
```


## Section 4.1: Logistic Regression Model


```{r k-nearest-neighbors}
# define model spec
knn_spec <- nearest_neighbor(mode = 'classification',
                            engine = 'kknn',
                            neighbors = parsnip::tune())

# define workflow
knn_wf <- workflow() %>% 
  add_recipe(knn_rec) %>% 
  add_model(knn_model)

# set tuning parameters
knn_params <- extract_parameter_set_dials(knn_wf) %>% 
  update(neighbors = neighbors(c(2, 50)))

# tune with grid
knn_tune <- tune_grid(knn_wf,
                      resamples = resamples,
                      grid = grid_regular(knn_params, levels = 49),
                      control = control_resamples(save_pred = TRUE)
                      )

# collect predictions and roc_auc from cross-validated fit
knn_preds <-  collect_predictions(knn_fit)


# get threshold selection info
knn_thresh_perf <- probably::threshold_perf(knn_preds,
                                            Class,
                                            .pred_Tarp,
                                            thresholds = seq(0.01, 0.99, 0.01),
                                            event_level = 'second',
                                            metrics = metric_set(j_index,
                                                                 specificity,
                                                                 sensitivity,
                                                                 accuracy))

# get threshold for best sensitivity
max_sens <- knn_thresh_perf %>% 
  filter(.metric == 'sensitivity') %>% 
  filter(.estimate == max(.estimate))

# get threshold for best j-index
max_j <- knn_thresh_perf %>% 
  filter(.metric == 'j_index') %>% 
  filter(.estimate == max(.estimate))

# get predictions based on chosen threshold
knn_preds <- knn_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.04, 'Tarp', 'Non-Tarp')))


```


> Write-up


```{r knn-auc-vs-metrics}
#| fig.width: 9
#| fig.height: 5
#| fig.align: center
#| out.width: 70%
#| fig.cap: Plot of ROC curve for the logistic regression model with no penalty. The AUC is 0.9976.
#| dev: "png"
#| dpi: 100
# display logreg ROC curve
roc_plot(logreg_preds)
```

> describe ROC curve, report AUC (without printing it out), and 

Figure 1 shows the corresponding ROC curve to demonstrate the performance of the model. We note a very high AUC of **0.9987**, indicating a very effective model. From the visualization and the ROC AUC metric, it is clear that the model performs well. To optimize its predictive capability, we now investigate further to choose a threshold.


```{r }
#| fig.width:8
#| fig.height: 8
#| fig.align: center
#| out.width: 70%
#| fig.cap: Visualization of logistic regression model metrics based on threshold, with vertical lines representing the maximum sensitivity at threshold = 0.9886 and maximum j-index at threshold = 0.10.
#| dev: "png"
#| dpi: 100
# display threshold metric plot for logistic regression
threshold_metric_plot(logreg_preds)
```

Figure 2 shows the metrics of the logistic regression based on threshold. The threshold that maximizes sensitivity is 0.01. The threshold that maximized j-index is 0.1. Since the plot shows that sensitivity is not too affected at threshold levels below 0.1, and j-index is significantly affected at lower levels, we choose 0.1 as the threshold for this model.

```{r logreg-final-metrics}
# display metrics
logreg_threshold_metrics
```

> talk about the metrics here



```{r logreg-cm}
# confusion matrix for logistic regression with threshold = 0.01
conf_mat(logreg_threshold_preds, truth = Class, estimate = .pred_class)
```



## Penalized Logistic Regression Model

```{r penalized-logistic-regression}
# define and execute cross validation workflow for logistic regression

pen_spec <- logistic_reg(engine = "glmnet",
                         mode = "classification",
                         penalty = parsnip::tune(),
                         mixture= parsnip::tune())

pen_wf <- workflow() %>% 
  add_recipe(rec) %>% 
  add_model(pen_spec)

pen_params <- extract_parameter_set_dials(pen_wf) %>% 
  update(penalty = penalty(c(-20, -1)),
         mixture = mixture(c(0, 1))
  )

pen_tune <- tune_grid(pen_wf,
                      resamples = resamples,
                      control = cv_control,
                      grid = grid_latin_hypercube(pen_params, size = 50))

best_params_logreg <- select_best(pen_tune, metric = "roc_auc")


# collect predictions and roc_auc from cross-validated fit


# collect metrics for finalized model


# finalize workflow and collect metrics


```

```{r}
pen_model <- pen_wf %>% 
  finalize_workflow(select_best(pen_tune, metric="roc_auc")) %>% 
  fit(train)
```




We set up the penalized logistic regression model that will be tuned on both a penalty factor and a mixture for the model. We experimented with the penalty parameter to find a range that included the lowest possible RMSE. Figure 3 shows how the ROC AUC responds to different levels of mixture and penalty. We note a drop off in RMSE for around penalty less than -5, and fairly even lasso penalty after .1 with sporadic models under performing across the range.

```{r figure-3}
#| fig.width: 9
#| fig.height: 5
#| fig.align: center
#| out.width: 70%
#| fig.cap: Visualization of ROC AUC based on penalty and mixture.
#| dev: "png"
#| dpi: 100
# visualize roc_auc based on mixture and penalty
autoplot(pen_tune)$roc_auc
```


Using cross-validation, the three best versions of the model were extracted based on ROC AUC, shown below. All three of the best models have a low mixture (closer to a ridge regression) and a low penalty.

>so what? what does that mean? Are we going to select_best or select_by_one_std_err? Why?

```{r best-pen-models}
# display best parameters and metrics for penalized logistic regression
show_best(pen_tune, metric = 'roc_auc', n = 3)
```




```{r Finalize_the_models}



cv_metrics <- bind_rows(
  collect_metrics(logreg_cv) %>%
    mutate(model="Logistic regression untuned"),
  show_best(pen_tune, metric="roc_auc", 1) %>%
    mutate(model="Logistic regression tuned"),
  
)
ggplot(cv_metrics, aes(x=mean, y=model, xmin=mean-std_err, xmax=mean+std_err))+
  geom_point()+
  geom_linerange()+
  facet_wrap(~ .metric)
```

```{r Final_ROC_AUC}

bind_rows(
  roc_auc(augment(logreg_untuned_model, test), Class, .pred_Tarp, event_level="second") %>%
    mutate(model="logreg untuned"),
  roc_auc(augment(pen_model, test), Class, .pred_Tarp, event_level="second") %>%
    mutate(model="logreg tuned"),
) %>%
ggplot(aes(x=.estimate, y=model)) +
  geom_point() +
  facet_wrap(~ .metric)
```



```{r logistic-cm}

log_preds <- collect_predictions(logreg_cv)
penalized_log_preds <- collect_predictions(pen_model_cv) 
```

```{r log_threshold}


penal_log_thres_perf <- probably::threshold_perf(penalized_log_preds,
                                           Class,
                                           .pred_Tarp,
                                           threshold=seq(0.01,0.99,0.01),
                                           event_level= "second",
                                           metrics= metric_set(j_index,
                                                               specificity,
                                                               sensitivity,
                                                               accuracy))
```

```{r log_metric_plot}

max_sens_log <- log_thres_perf %>% 
  filter(.metric == 'sensitivity') %>% 
  filter(.estimate == max(.estimate))

max_j_log <- log_thres_perf %>% 
  filter(.metric == 'j_index') %>% 
  filter(.estimate == max(.estimate))

max_sens_pen <- penal_log_thres_perf %>% 
  filter(.metric == 'sensitivity') %>% 
  filter(.estimate == max(.estimate))

max_j_pen <- penal_log_thres_perf %>% 
  filter(.metric == 'j_index') %>% 
  filter(.estimate == max(.estimate))
  

```

The threshold plots for these models show that for both models when maximizing the sensitivity they share the same threshold at .01. We are interested in maximizing sensitivity as time to first response is the most important thing in disaster scenarios. For this circumstance that means that we want to set the thresholds to the .01. Additionally, while this decision does sacrifice total performance the j-index for both metrics still performs at .94 for the log model and .90 for the penalized log model reflecting a respectable score overall.
```{r log_threshold_plots}

ggplot(log_thres_perf, aes(x = .threshold, y = .estimate, color = .metric)) +
  geom_line() +
  geom_vline(data = max_sens_log, aes(xintercept = .threshold, color = .metric)) +
  geom_vline(data = max_j_log, aes(xintercept = .threshold, color = .metric)) +
  scale_x_continuous(breaks = seq(0, 1, 0.1)) +
  labs(title= "Logistic Model",x = 'Threshold', y = 'Metric value')

ggplot(log_thres_perf, aes(x = .threshold, y = .estimate, color = .metric)) +
  geom_line() +
  geom_vline(data = max_sens_pen, aes(xintercept = .threshold, color = .metric)) +
  geom_vline(data = max_j_pen, aes(xintercept = .threshold, color = .metric)) +
  scale_x_continuous(breaks = seq(0, 1, 0.1)) +
  labs(title= "Penalized Logistic Model", x = 'Threshold', y = 'Metric value')

```
The confusion matrix when the thresholds are set to maximizing the sensitivity for both metrics results in only 12 false negatives for the base logistic model and 2 for the penalized logistic regression model. Depending on the circumstances it may be worthwhile to examine a more balanced threshold which is done by selecting the J-index max below. These would be more useful if resources are limited and the rescue team does not have the resources to full examine all options. This does however result in more false negatives with 37 and 34 respectively that could be potentially damaging to response efforts.
```{r log_conf_matrix}

# Confusion Matrices for the Logistic Regression Models
log_preds <- log_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.01, 'Tarp', 'Non-Tarp')))
conf_mat(log_preds, truth = Class, estimate = .pred_class)

log_preds <- log_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.5, 'Tarp', 'Non-Tarp')))
conf_mat(log_preds, truth = Class, estimate = .pred_class)

log_preds <- log_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.04, 'Tarp', 'Non-Tarp')))
conf_mat(log_preds, truth = Class, estimate = .pred_class)

writeLines("\n\n")

# Confusion Matrices for the penalized logistic regresion models
penalized_log_preds <- penalized_log_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.01, 'Tarp', 'Non-Tarp')))
conf_mat(penalized_log_preds, truth = Class, estimate = .pred_class)

penalized_log_preds <- penalized_log_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.5, 'Tarp', 'Non-Tarp')))
conf_mat(penalized_log_preds, truth = Class, estimate = .pred_class)

penalized_log_preds <- penalized_log_preds %>% 
  mutate(.pred_class = factor(ifelse(.pred_Tarp >= 0.05, 'Tarp', 'Non-Tarp')))
conf_mat(penalized_log_preds, truth = Class, estimate = .pred_class)



```

```{r log_metrics_training}

get_metrics <- metric_set(j_index, sensitivity, specificity, accuracy)

# Get Metrics on train data
log_train_metrics <- log_preds %>% 
  get_metrics(truth= Class, estimate = .pred_class)

pen_log_train_metrics <- penalized_log_preds %>% 
  get_metrics(truth= Class, estimate = .pred_class)

# Get Metrics on test data

log_test_metrics <- parsnip::augment(logreg_untuned_model, new_data = test) %>% 
  get_metrics(truth = Class, estimate = .pred_class)

pen_log_test_metrics <- parsnip::augment(pen_model, new_data = test) %>% 
  get_metrics(truth = Class, estimate = .pred_class)

```

When evaluating the final model we note that the penalized and non penalized model both have very similar scores of sensitivity of .999 with their testing sets. While the models are similar in this regard all other metrics are outperformed by the base model rather than the penalized model. While our goal should be to maximize the sensitivity going with the Logistic Regression model will allow us more flexibility when it comes to instances where we are interested in more balanced outputs. For that reason we would select the Logistic Regression model over the Penalized Logistic Regression Model as our final ideal model.

```{r final_metrics_comparison}

bind_rows(log_train_metrics %>% mutate(data ="Log Training"),
          log_test_metrics %>% mutate(data = "Log Testing"),
          pen_log_train_metrics %>% mutate(data = "Penalized Log Training"),
          pen_log_test_metrics %>% mutate(data = "Penalized Log Testing")) %>% 
  pivot_wider(id_cols = .metric,
              names_from = data,
              values_from = .estimate)


```

















# Section 5: Conclusion


>Three or more clearly identifiable conclusions. This section is more important than the previous sections (as
reflected in the points). Give sufficient explanation and justification for each conclusion.
One conclusion must be:
• determination and justification of which algorithm works best.
Additional conclusions should be observations you’ve made based on your work on this project, such as:
• What additional recommend actions can be taken to improve results?
• Were there multiple adequately performing methods, or just one clear best method? What is your level
of confidence in the results?
• What is it about this data formulation that allows us to address it with predictive modeling tools?
• How effective do you think your work here could actually be in terms of helping to save human life?
• Do these data seem particularly well-suited to one class of prediction methods, and if so, why?
These are only suggestions, pursue your own interests. Your best two additional conclusions will be graded.
Make sure that the 3 conclusions are clearly separated.










# Appendix

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
stopCluster(cl)
registerDoSEQ()
```
